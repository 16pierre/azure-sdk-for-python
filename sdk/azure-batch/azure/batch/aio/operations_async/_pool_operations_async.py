# coding=utf-8
# --------------------------------------------------------------------------
# Copyright (c) Microsoft Corporation. All rights reserved.
# Licensed under the MIT License. See License.txt in the project root for license information.
# Code generated by Microsoft (R) AutoRest Code Generator.
# Changes may cause incorrect behavior and will be lost if the code is regenerated.
# --------------------------------------------------------------------------
import datetime
from typing import Any, Callable, Dict, Generic, Optional, TypeVar
import warnings

from azure.core.async_paging import AsyncItemPaged, AsyncList
from azure.core.exceptions import HttpResponseError, ResourceExistsError, ResourceNotFoundError, map_error
from azure.core.pipeline import PipelineResponse
from azure.core.pipeline.transport import AsyncHttpResponse, HttpRequest
from azure.mgmt.core.exceptions import ARMErrorFormat

from ... import models

T = TypeVar('T')
ClsType = Optional[Callable[[PipelineResponse[HttpRequest, AsyncHttpResponse], T, Dict[str, Any]], Any]]

class PoolOperations:
    """PoolOperations async operations.

    You should not instantiate this class directly. Instead, you should create a Client instance that
    instantiates it for you and attaches it as an attribute.

    :ivar models: Alias to model classes used in this operation group.
    :type models: ~azure.batch.models
    :param client: Client for service requests.
    :param config: Configuration of service client.
    :param serializer: An object model serializer.
    :param deserializer: An object model deserializer.
    """

    models = models

    def __init__(self, client, config, serializer, deserializer) -> None:
        self._client = client
        self._serialize = serializer
        self._deserialize = deserializer
        self._config = config

    def list_usage_metrics(
        self,
        pool_list_usage_metrics_options: Optional["models.PoolListUsageMetricsOptions"] = None,
        **kwargs
    ) -> "models.PoolListUsageMetricsResult":
        """If you do not specify a $filter clause including a poolId, the response includes all Pools that existed in the Account in the time range of the returned aggregation intervals. If you do not specify a $filter clause including a startTime or endTime these filters default to the start and end times of the last aggregation interval currently available; that is, only the last aggregation interval is returned.

        Lists the usage metrics, aggregated by Pool across individual time intervals, for the specified
    Account.

        :param pool_list_usage_metrics_options: Parameter group.
        :type pool_list_usage_metrics_options: ~azure.batch.models.PoolListUsageMetricsOptions
        :keyword callable cls: A custom type or function that will be passed the direct response
        :return: PoolListUsageMetricsResult or the result of cls(response)
        :rtype: ~azure.batch.models.PoolListUsageMetricsResult
        :raises: ~azure.core.exceptions.HttpResponseError
        """
        cls = kwargs.pop('cls', None)  # type: ClsType["models.PoolListUsageMetricsResult"]
        error_map = kwargs.pop('error_map', {404: ResourceNotFoundError, 409: ResourceExistsError})
        
        _start_time = None
        _end_time = None
        _filter = None
        _max_results = None
        _timeout = None
        _client_request_id = None
        _return_client_request_id = None
        _ocp_date = None
        if pool_list_usage_metrics_options is not None:
            _start_time = pool_list_usage_metrics_options.start_time
            _end_time = pool_list_usage_metrics_options.end_time
            _filter = pool_list_usage_metrics_options.filter
            _max_results = pool_list_usage_metrics_options.max_results
            _timeout = pool_list_usage_metrics_options.timeout
            _client_request_id = pool_list_usage_metrics_options.client_request_id
            _return_client_request_id = pool_list_usage_metrics_options.return_client_request_id
            _ocp_date = pool_list_usage_metrics_options.ocp_date
        api_version = "2020-03-01.11.0"

        def prepare_request(next_link=None):
            if not next_link:
                # Construct URL
                url = self.list_usage_metrics.metadata['url']
                path_format_arguments = {
                    'batchUrl': self._serialize.url("self._config.batch_url", self._config.batch_url, 'str', skip_quote=True),
                }
                url = self._client.format_url(url, **path_format_arguments)
            else:
                url = next_link
                path_format_arguments = {
                    'batchUrl': self._serialize.url("self._config.batch_url", self._config.batch_url, 'str', skip_quote=True),
                }
                url = self._client.format_url(url, **path_format_arguments)

            # Construct parameters
            query_parameters = {}  # type: Dict[str, Any]
            if _start_time is not None:
                query_parameters['starttime'] = self._serialize.query("start_time", _start_time, 'iso-8601')
            if _end_time is not None:
                query_parameters['endtime'] = self._serialize.query("end_time", _end_time, 'iso-8601')
            if _filter is not None:
                query_parameters['$filter'] = self._serialize.query("filter", _filter, 'str')
            if _max_results is not None:
                query_parameters['maxresults'] = self._serialize.query("max_results", _max_results, 'int', maximum=1000, minimum=1)
            if _timeout is not None:
                query_parameters['timeout'] = self._serialize.query("timeout", _timeout, 'int')
            query_parameters['api-version'] = self._serialize.query("api_version", api_version, 'str')

            # Construct headers
            header_parameters = {}  # type: Dict[str, Any]
            if _client_request_id is not None:
                header_parameters['client-request-id'] = self._serialize.header("client_request_id", _client_request_id, 'str')
            if _return_client_request_id is not None:
                header_parameters['return-client-request-id'] = self._serialize.header("return_client_request_id", _return_client_request_id, 'bool')
            if _ocp_date is not None:
                header_parameters['ocp-date'] = self._serialize.header("ocp_date", _ocp_date, 'rfc-1123')
            header_parameters['Accept'] = 'application/json'

            # Construct and send request
            request = self._client.get(url, query_parameters, header_parameters)
            return request

        async def extract_data(pipeline_response):
            deserialized = self._deserialize('PoolListUsageMetricsResult', pipeline_response)
            list_of_elem = deserialized.value
            if cls:
                list_of_elem = cls(list_of_elem)
            return deserialized.odata_next_link or None, AsyncList(list_of_elem)

        async def get_next(next_link=None):
            request = prepare_request(next_link)

            pipeline_response = await self._client._pipeline.run(request, stream=False, **kwargs)
            response = pipeline_response.http_response

            if response.status_code not in [200]:
                error = self._deserialize(models.BatchError, response)
                map_error(status_code=response.status_code, response=response, error_map=error_map)
                raise HttpResponseError(response=response, model=error, error_format=ARMErrorFormat)

            return pipeline_response

        return AsyncItemPaged(
            get_next, extract_data
        )
    list_usage_metrics.metadata = {'url': '/poolusagemetrics'}

    async def get_all_lifetime_statistics(
        self,
        pool_get_all_lifetime_statistics_options: Optional["models.PoolGetAllLifetimeStatisticsOptions"] = None,
        **kwargs
    ) -> "models.PoolStatistics":
        """Statistics are aggregated across all Pools that have ever existed in the Account, from Account creation to the last update time of the statistics. The statistics may not be immediately available. The Batch service performs periodic roll-up of statistics. The typical delay is about 30 minutes.

        Gets lifetime summary statistics for all of the Pools in the specified Account.

        :param pool_get_all_lifetime_statistics_options: Parameter group.
        :type pool_get_all_lifetime_statistics_options: ~azure.batch.models.PoolGetAllLifetimeStatisticsOptions
        :keyword callable cls: A custom type or function that will be passed the direct response
        :return: PoolStatistics or the result of cls(response)
        :rtype: ~azure.batch.models.PoolStatistics
        :raises: ~azure.core.exceptions.HttpResponseError
        """
        cls = kwargs.pop('cls', None)  # type: ClsType["models.PoolStatistics"]
        error_map = kwargs.pop('error_map', {404: ResourceNotFoundError, 409: ResourceExistsError})
        
        _timeout = None
        _client_request_id = None
        _return_client_request_id = None
        _ocp_date = None
        if pool_get_all_lifetime_statistics_options is not None:
            _timeout = pool_get_all_lifetime_statistics_options.timeout
            _client_request_id = pool_get_all_lifetime_statistics_options.client_request_id
            _return_client_request_id = pool_get_all_lifetime_statistics_options.return_client_request_id
            _ocp_date = pool_get_all_lifetime_statistics_options.ocp_date
        api_version = "2020-03-01.11.0"

        # Construct URL
        url = self.get_all_lifetime_statistics.metadata['url']
        path_format_arguments = {
            'batchUrl': self._serialize.url("self._config.batch_url", self._config.batch_url, 'str', skip_quote=True),
        }
        url = self._client.format_url(url, **path_format_arguments)

        # Construct parameters
        query_parameters = {}  # type: Dict[str, Any]
        if _timeout is not None:
            query_parameters['timeout'] = self._serialize.query("timeout", _timeout, 'int')
        query_parameters['api-version'] = self._serialize.query("api_version", api_version, 'str')

        # Construct headers
        header_parameters = {}  # type: Dict[str, Any]
        if _client_request_id is not None:
            header_parameters['client-request-id'] = self._serialize.header("client_request_id", _client_request_id, 'str')
        if _return_client_request_id is not None:
            header_parameters['return-client-request-id'] = self._serialize.header("return_client_request_id", _return_client_request_id, 'bool')
        if _ocp_date is not None:
            header_parameters['ocp-date'] = self._serialize.header("ocp_date", _ocp_date, 'rfc-1123')
        header_parameters['Accept'] = 'application/json'

        # Construct and send request
        request = self._client.get(url, query_parameters, header_parameters)
        pipeline_response = await self._client._pipeline.run(request, stream=False, **kwargs)
        response = pipeline_response.http_response

        if response.status_code not in [200]:
            map_error(status_code=response.status_code, response=response, error_map=error_map)
            error = self._deserialize(models.BatchError, response)
            raise HttpResponseError(response=response, model=error, error_format=ARMErrorFormat)

        response_headers = {}
        response_headers['client-request-id']=self._deserialize('str', response.headers.get('client-request-id'))
        response_headers['request-id']=self._deserialize('str', response.headers.get('request-id'))
        response_headers['ETag']=self._deserialize('str', response.headers.get('ETag'))
        response_headers['Last-Modified']=self._deserialize('rfc-1123', response.headers.get('Last-Modified'))
        deserialized = self._deserialize('PoolStatistics', pipeline_response)

        if cls:
          return cls(pipeline_response, deserialized, response_headers)

        return deserialized
    get_all_lifetime_statistics.metadata = {'url': '/lifetimepoolstats'}

    async def add(
        self,
        pool: "models.PoolAddParameter",
        pool_add_options: Optional["models.PoolAddOptions"] = None,
        **kwargs
    ) -> None:
        """When naming Pools, avoid including sensitive information such as user names or secret project names. This information may appear in telemetry logs accessible to Microsoft Support engineers.

        Adds a Pool to the specified Account.

        :param pool: The Pool to be added.
        :type pool: ~azure.batch.models.PoolAddParameter
        :param pool_add_options: Parameter group.
        :type pool_add_options: ~azure.batch.models.PoolAddOptions
        :keyword callable cls: A custom type or function that will be passed the direct response
        :return: None or the result of cls(response)
        :rtype: None
        :raises: ~azure.core.exceptions.HttpResponseError
        """
        cls = kwargs.pop('cls', None)  # type: ClsType[None]
        error_map = kwargs.pop('error_map', {404: ResourceNotFoundError, 409: ResourceExistsError})
        
        _timeout = None
        _client_request_id = None
        _return_client_request_id = None
        _ocp_date = None
        if pool_add_options is not None:
            _timeout = pool_add_options.timeout
            _client_request_id = pool_add_options.client_request_id
            _return_client_request_id = pool_add_options.return_client_request_id
            _ocp_date = pool_add_options.ocp_date
        api_version = "2020-03-01.11.0"
        content_type = kwargs.pop("content_type", "application/json; odata=minimalmetadata")

        # Construct URL
        url = self.add.metadata['url']
        path_format_arguments = {
            'batchUrl': self._serialize.url("self._config.batch_url", self._config.batch_url, 'str', skip_quote=True),
        }
        url = self._client.format_url(url, **path_format_arguments)

        # Construct parameters
        query_parameters = {}  # type: Dict[str, Any]
        if _timeout is not None:
            query_parameters['timeout'] = self._serialize.query("timeout", _timeout, 'int')
        query_parameters['api-version'] = self._serialize.query("api_version", api_version, 'str')

        # Construct headers
        header_parameters = {}  # type: Dict[str, Any]
        if _client_request_id is not None:
            header_parameters['client-request-id'] = self._serialize.header("client_request_id", _client_request_id, 'str')
        if _return_client_request_id is not None:
            header_parameters['return-client-request-id'] = self._serialize.header("return_client_request_id", _return_client_request_id, 'bool')
        if _ocp_date is not None:
            header_parameters['ocp-date'] = self._serialize.header("ocp_date", _ocp_date, 'rfc-1123')
        header_parameters['Content-Type'] = self._serialize.header("content_type", content_type, 'str')

        # Construct and send request
        body_content_kwargs = {}  # type: Dict[str, Any]
        body_content = self._serialize.body(pool, 'PoolAddParameter')
        body_content_kwargs['content'] = body_content
        request = self._client.post(url, query_parameters, header_parameters, **body_content_kwargs)

        pipeline_response = await self._client._pipeline.run(request, stream=False, **kwargs)
        response = pipeline_response.http_response

        if response.status_code not in [201]:
            map_error(status_code=response.status_code, response=response, error_map=error_map)
            error = self._deserialize(models.BatchError, response)
            raise HttpResponseError(response=response, model=error, error_format=ARMErrorFormat)

        response_headers = {}
        response_headers['client-request-id']=self._deserialize('str', response.headers.get('client-request-id'))
        response_headers['request-id']=self._deserialize('str', response.headers.get('request-id'))
        response_headers['ETag']=self._deserialize('str', response.headers.get('ETag'))
        response_headers['Last-Modified']=self._deserialize('rfc-1123', response.headers.get('Last-Modified'))
        response_headers['DataServiceId']=self._deserialize('str', response.headers.get('DataServiceId'))

        if cls:
          return cls(pipeline_response, None, response_headers)

    add.metadata = {'url': '/pools'}

    def list(
        self,
        pool_list_options: Optional["models.PoolListOptions"] = None,
        **kwargs
    ) -> "models.CloudPoolListResult":
        """Lists all of the Pools in the specified Account.

        Lists all of the Pools in the specified Account.

        :param pool_list_options: Parameter group.
        :type pool_list_options: ~azure.batch.models.PoolListOptions
        :keyword callable cls: A custom type or function that will be passed the direct response
        :return: CloudPoolListResult or the result of cls(response)
        :rtype: ~azure.batch.models.CloudPoolListResult
        :raises: ~azure.core.exceptions.HttpResponseError
        """
        cls = kwargs.pop('cls', None)  # type: ClsType["models.CloudPoolListResult"]
        error_map = kwargs.pop('error_map', {404: ResourceNotFoundError, 409: ResourceExistsError})
        
        _filter = None
        _select = None
        _expand = None
        _max_results = None
        _timeout = None
        _client_request_id = None
        _return_client_request_id = None
        _ocp_date = None
        if pool_list_options is not None:
            _filter = pool_list_options.filter
            _select = pool_list_options.select
            _expand = pool_list_options.expand
            _max_results = pool_list_options.max_results
            _timeout = pool_list_options.timeout
            _client_request_id = pool_list_options.client_request_id
            _return_client_request_id = pool_list_options.return_client_request_id
            _ocp_date = pool_list_options.ocp_date
        api_version = "2020-03-01.11.0"

        def prepare_request(next_link=None):
            if not next_link:
                # Construct URL
                url = self.list.metadata['url']
                path_format_arguments = {
                    'batchUrl': self._serialize.url("self._config.batch_url", self._config.batch_url, 'str', skip_quote=True),
                }
                url = self._client.format_url(url, **path_format_arguments)
            else:
                url = next_link
                path_format_arguments = {
                    'batchUrl': self._serialize.url("self._config.batch_url", self._config.batch_url, 'str', skip_quote=True),
                }
                url = self._client.format_url(url, **path_format_arguments)

            # Construct parameters
            query_parameters = {}  # type: Dict[str, Any]
            if _filter is not None:
                query_parameters['$filter'] = self._serialize.query("filter", _filter, 'str')
            if _select is not None:
                query_parameters['$select'] = self._serialize.query("select", _select, 'str')
            if _expand is not None:
                query_parameters['$expand'] = self._serialize.query("expand", _expand, 'str')
            if _max_results is not None:
                query_parameters['maxresults'] = self._serialize.query("max_results", _max_results, 'int', maximum=1000, minimum=1)
            if _timeout is not None:
                query_parameters['timeout'] = self._serialize.query("timeout", _timeout, 'int')
            query_parameters['api-version'] = self._serialize.query("api_version", api_version, 'str')

            # Construct headers
            header_parameters = {}  # type: Dict[str, Any]
            if _client_request_id is not None:
                header_parameters['client-request-id'] = self._serialize.header("client_request_id", _client_request_id, 'str')
            if _return_client_request_id is not None:
                header_parameters['return-client-request-id'] = self._serialize.header("return_client_request_id", _return_client_request_id, 'bool')
            if _ocp_date is not None:
                header_parameters['ocp-date'] = self._serialize.header("ocp_date", _ocp_date, 'rfc-1123')
            header_parameters['Accept'] = 'application/json'

            # Construct and send request
            request = self._client.get(url, query_parameters, header_parameters)
            return request

        async def extract_data(pipeline_response):
            deserialized = self._deserialize('CloudPoolListResult', pipeline_response)
            list_of_elem = deserialized.value
            if cls:
                list_of_elem = cls(list_of_elem)
            return deserialized.odata_next_link or None, AsyncList(list_of_elem)

        async def get_next(next_link=None):
            request = prepare_request(next_link)

            pipeline_response = await self._client._pipeline.run(request, stream=False, **kwargs)
            response = pipeline_response.http_response

            if response.status_code not in [200]:
                error = self._deserialize(models.BatchError, response)
                map_error(status_code=response.status_code, response=response, error_map=error_map)
                raise HttpResponseError(response=response, model=error, error_format=ARMErrorFormat)

            return pipeline_response

        return AsyncItemPaged(
            get_next, extract_data
        )
    list.metadata = {'url': '/pools'}

    async def delete(
        self,
        pool_id: str,
        pool_delete_options: Optional["models.PoolDeleteOptions"] = None,
        **kwargs
    ) -> None:
        """When you request that a Pool be deleted, the following actions occur: the Pool state is set to deleting; any ongoing resize operation on the Pool are stopped; the Batch service starts resizing the Pool to zero Compute Nodes; any Tasks running on existing Compute Nodes are terminated and requeued (as if a resize Pool operation had been requested with the default requeue option); finally, the Pool is removed from the system. Because running Tasks are requeued, the user can rerun these Tasks by updating their Job to target a different Pool. The Tasks can then run on the new Pool. If you want to override the requeue behavior, then you should call resize Pool explicitly to shrink the Pool to zero size before deleting the Pool. If you call an Update, Patch or Delete API on a Pool in the deleting state, it will fail with HTTP status code 409 with error code PoolBeingDeleted.

        Deletes a Pool from the specified Account.

        :param pool_id: The ID of the Pool to delete.
        :type pool_id: str
        :param pool_delete_options: Parameter group.
        :type pool_delete_options: ~azure.batch.models.PoolDeleteOptions
        :keyword callable cls: A custom type or function that will be passed the direct response
        :return: None or the result of cls(response)
        :rtype: None
        :raises: ~azure.core.exceptions.HttpResponseError
        """
        cls = kwargs.pop('cls', None)  # type: ClsType[None]
        error_map = kwargs.pop('error_map', {404: ResourceNotFoundError, 409: ResourceExistsError})
        
        _timeout = None
        _client_request_id = None
        _return_client_request_id = None
        _ocp_date = None
        _if_match = None
        _if_none_match = None
        _if_modified_since = None
        _if_unmodified_since = None
        if pool_delete_options is not None:
            _timeout = pool_delete_options.timeout
            _client_request_id = pool_delete_options.client_request_id
            _return_client_request_id = pool_delete_options.return_client_request_id
            _ocp_date = pool_delete_options.ocp_date
            _if_match = pool_delete_options.if_match
            _if_none_match = pool_delete_options.if_none_match
            _if_modified_since = pool_delete_options.if_modified_since
            _if_unmodified_since = pool_delete_options.if_unmodified_since
        api_version = "2020-03-01.11.0"

        # Construct URL
        url = self.delete.metadata['url']
        path_format_arguments = {
            'batchUrl': self._serialize.url("self._config.batch_url", self._config.batch_url, 'str', skip_quote=True),
            'poolId': self._serialize.url("pool_id", pool_id, 'str'),
        }
        url = self._client.format_url(url, **path_format_arguments)

        # Construct parameters
        query_parameters = {}  # type: Dict[str, Any]
        if _timeout is not None:
            query_parameters['timeout'] = self._serialize.query("timeout", _timeout, 'int')
        query_parameters['api-version'] = self._serialize.query("api_version", api_version, 'str')

        # Construct headers
        header_parameters = {}  # type: Dict[str, Any]
        if _client_request_id is not None:
            header_parameters['client-request-id'] = self._serialize.header("client_request_id", _client_request_id, 'str')
        if _return_client_request_id is not None:
            header_parameters['return-client-request-id'] = self._serialize.header("return_client_request_id", _return_client_request_id, 'bool')
        if _ocp_date is not None:
            header_parameters['ocp-date'] = self._serialize.header("ocp_date", _ocp_date, 'rfc-1123')
        if _if_match is not None:
            header_parameters['If-Match'] = self._serialize.header("if_match", _if_match, 'str')
        if _if_none_match is not None:
            header_parameters['If-None-Match'] = self._serialize.header("if_none_match", _if_none_match, 'str')
        if _if_modified_since is not None:
            header_parameters['If-Modified-Since'] = self._serialize.header("if_modified_since", _if_modified_since, 'rfc-1123')
        if _if_unmodified_since is not None:
            header_parameters['If-Unmodified-Since'] = self._serialize.header("if_unmodified_since", _if_unmodified_since, 'rfc-1123')

        # Construct and send request
        request = self._client.delete(url, query_parameters, header_parameters)
        pipeline_response = await self._client._pipeline.run(request, stream=False, **kwargs)
        response = pipeline_response.http_response

        if response.status_code not in [202]:
            map_error(status_code=response.status_code, response=response, error_map=error_map)
            error = self._deserialize(models.BatchError, response)
            raise HttpResponseError(response=response, model=error, error_format=ARMErrorFormat)

        response_headers = {}
        response_headers['client-request-id']=self._deserialize('str', response.headers.get('client-request-id'))
        response_headers['request-id']=self._deserialize('str', response.headers.get('request-id'))

        if cls:
          return cls(pipeline_response, None, response_headers)

    delete.metadata = {'url': '/pools/{poolId}'}

    async def exists(
        self,
        pool_id: str,
        pool_exists_options: Optional["models.PoolExistsOptions"] = None,
        **kwargs
    ) -> None:
        """Gets basic properties of a Pool.

        :param pool_id: The ID of the Pool to get.
        :type pool_id: str
        :param pool_exists_options: Parameter group.
        :type pool_exists_options: ~azure.batch.models.PoolExistsOptions
        :keyword callable cls: A custom type or function that will be passed the direct response
        :return: None or the result of cls(response)
        :rtype: None
        :raises: ~azure.core.exceptions.HttpResponseError
        """
        cls = kwargs.pop('cls', None)  # type: ClsType[None]
        error_map = kwargs.pop('error_map', {404: ResourceNotFoundError, 409: ResourceExistsError})
        
        _timeout = None
        _client_request_id = None
        _return_client_request_id = None
        _ocp_date = None
        _if_match = None
        _if_none_match = None
        _if_modified_since = None
        _if_unmodified_since = None
        if pool_exists_options is not None:
            _timeout = pool_exists_options.timeout
            _client_request_id = pool_exists_options.client_request_id
            _return_client_request_id = pool_exists_options.return_client_request_id
            _ocp_date = pool_exists_options.ocp_date
            _if_match = pool_exists_options.if_match
            _if_none_match = pool_exists_options.if_none_match
            _if_modified_since = pool_exists_options.if_modified_since
            _if_unmodified_since = pool_exists_options.if_unmodified_since
        api_version = "2020-03-01.11.0"

        # Construct URL
        url = self.exists.metadata['url']
        path_format_arguments = {
            'batchUrl': self._serialize.url("self._config.batch_url", self._config.batch_url, 'str', skip_quote=True),
            'poolId': self._serialize.url("pool_id", pool_id, 'str'),
        }
        url = self._client.format_url(url, **path_format_arguments)

        # Construct parameters
        query_parameters = {}  # type: Dict[str, Any]
        if _timeout is not None:
            query_parameters['timeout'] = self._serialize.query("timeout", _timeout, 'int')
        query_parameters['api-version'] = self._serialize.query("api_version", api_version, 'str')

        # Construct headers
        header_parameters = {}  # type: Dict[str, Any]
        if _client_request_id is not None:
            header_parameters['client-request-id'] = self._serialize.header("client_request_id", _client_request_id, 'str')
        if _return_client_request_id is not None:
            header_parameters['return-client-request-id'] = self._serialize.header("return_client_request_id", _return_client_request_id, 'bool')
        if _ocp_date is not None:
            header_parameters['ocp-date'] = self._serialize.header("ocp_date", _ocp_date, 'rfc-1123')
        if _if_match is not None:
            header_parameters['If-Match'] = self._serialize.header("if_match", _if_match, 'str')
        if _if_none_match is not None:
            header_parameters['If-None-Match'] = self._serialize.header("if_none_match", _if_none_match, 'str')
        if _if_modified_since is not None:
            header_parameters['If-Modified-Since'] = self._serialize.header("if_modified_since", _if_modified_since, 'rfc-1123')
        if _if_unmodified_since is not None:
            header_parameters['If-Unmodified-Since'] = self._serialize.header("if_unmodified_since", _if_unmodified_since, 'rfc-1123')

        # Construct and send request
        request = self._client.head(url, query_parameters, header_parameters)
        pipeline_response = await self._client._pipeline.run(request, stream=False, **kwargs)
        response = pipeline_response.http_response

        if response.status_code not in [200, 404]:
            map_error(status_code=response.status_code, response=response, error_map=error_map)
            error = self._deserialize(models.BatchError, response)
            raise HttpResponseError(response=response, model=error, error_format=ARMErrorFormat)

        response_headers = {}
        if response.status_code == 200:
            response_headers['client-request-id']=self._deserialize('str', response.headers.get('client-request-id'))
            response_headers['request-id']=self._deserialize('str', response.headers.get('request-id'))
            response_headers['ETag']=self._deserialize('str', response.headers.get('ETag'))
            response_headers['Last-Modified']=self._deserialize('rfc-1123', response.headers.get('Last-Modified'))

        if cls:
          return cls(pipeline_response, None, response_headers)

        return 200 <= response.status_code <= 299
    exists.metadata = {'url': '/pools/{poolId}'}

    async def get(
        self,
        pool_id: str,
        pool_get_options: Optional["models.PoolGetOptions"] = None,
        **kwargs
    ) -> "models.CloudPool":
        """Gets information about the specified Pool.

        :param pool_id: The ID of the Pool to get.
        :type pool_id: str
        :param pool_get_options: Parameter group.
        :type pool_get_options: ~azure.batch.models.PoolGetOptions
        :keyword callable cls: A custom type or function that will be passed the direct response
        :return: CloudPool or the result of cls(response)
        :rtype: ~azure.batch.models.CloudPool
        :raises: ~azure.core.exceptions.HttpResponseError
        """
        cls = kwargs.pop('cls', None)  # type: ClsType["models.CloudPool"]
        error_map = kwargs.pop('error_map', {404: ResourceNotFoundError, 409: ResourceExistsError})
        
        _select = None
        _expand = None
        _timeout = None
        _client_request_id = None
        _return_client_request_id = None
        _ocp_date = None
        _if_match = None
        _if_none_match = None
        _if_modified_since = None
        _if_unmodified_since = None
        if pool_get_options is not None:
            _select = pool_get_options.select
            _expand = pool_get_options.expand
            _timeout = pool_get_options.timeout
            _client_request_id = pool_get_options.client_request_id
            _return_client_request_id = pool_get_options.return_client_request_id
            _ocp_date = pool_get_options.ocp_date
            _if_match = pool_get_options.if_match
            _if_none_match = pool_get_options.if_none_match
            _if_modified_since = pool_get_options.if_modified_since
            _if_unmodified_since = pool_get_options.if_unmodified_since
        api_version = "2020-03-01.11.0"

        # Construct URL
        url = self.get.metadata['url']
        path_format_arguments = {
            'batchUrl': self._serialize.url("self._config.batch_url", self._config.batch_url, 'str', skip_quote=True),
            'poolId': self._serialize.url("pool_id", pool_id, 'str'),
        }
        url = self._client.format_url(url, **path_format_arguments)

        # Construct parameters
        query_parameters = {}  # type: Dict[str, Any]
        if _select is not None:
            query_parameters['$select'] = self._serialize.query("select", _select, 'str')
        if _expand is not None:
            query_parameters['$expand'] = self._serialize.query("expand", _expand, 'str')
        if _timeout is not None:
            query_parameters['timeout'] = self._serialize.query("timeout", _timeout, 'int')
        query_parameters['api-version'] = self._serialize.query("api_version", api_version, 'str')

        # Construct headers
        header_parameters = {}  # type: Dict[str, Any]
        if _client_request_id is not None:
            header_parameters['client-request-id'] = self._serialize.header("client_request_id", _client_request_id, 'str')
        if _return_client_request_id is not None:
            header_parameters['return-client-request-id'] = self._serialize.header("return_client_request_id", _return_client_request_id, 'bool')
        if _ocp_date is not None:
            header_parameters['ocp-date'] = self._serialize.header("ocp_date", _ocp_date, 'rfc-1123')
        if _if_match is not None:
            header_parameters['If-Match'] = self._serialize.header("if_match", _if_match, 'str')
        if _if_none_match is not None:
            header_parameters['If-None-Match'] = self._serialize.header("if_none_match", _if_none_match, 'str')
        if _if_modified_since is not None:
            header_parameters['If-Modified-Since'] = self._serialize.header("if_modified_since", _if_modified_since, 'rfc-1123')
        if _if_unmodified_since is not None:
            header_parameters['If-Unmodified-Since'] = self._serialize.header("if_unmodified_since", _if_unmodified_since, 'rfc-1123')
        header_parameters['Accept'] = 'application/json'

        # Construct and send request
        request = self._client.get(url, query_parameters, header_parameters)
        pipeline_response = await self._client._pipeline.run(request, stream=False, **kwargs)
        response = pipeline_response.http_response

        if response.status_code not in [200]:
            map_error(status_code=response.status_code, response=response, error_map=error_map)
            error = self._deserialize(models.BatchError, response)
            raise HttpResponseError(response=response, model=error, error_format=ARMErrorFormat)

        response_headers = {}
        response_headers['client-request-id']=self._deserialize('str', response.headers.get('client-request-id'))
        response_headers['request-id']=self._deserialize('str', response.headers.get('request-id'))
        response_headers['ETag']=self._deserialize('str', response.headers.get('ETag'))
        response_headers['Last-Modified']=self._deserialize('rfc-1123', response.headers.get('Last-Modified'))
        deserialized = self._deserialize('CloudPool', pipeline_response)

        if cls:
          return cls(pipeline_response, deserialized, response_headers)

        return deserialized
    get.metadata = {'url': '/pools/{poolId}'}

    async def patch(
        self,
        pool_id: str,
        pool_patch_parameter: "models.PoolPatchParameter",
        pool_patch_options: Optional["models.PoolPatchOptions"] = None,
        **kwargs
    ) -> None:
        """This only replaces the Pool properties specified in the request. For example, if the Pool has a StartTask associated with it, and a request does not specify a StartTask element, then the Pool keeps the existing StartTask.

        Updates the properties of the specified Pool.

        :param pool_id: The ID of the Pool to update.
        :type pool_id: str
        :param pool_patch_parameter: The parameters for the request.
        :type pool_patch_parameter: ~azure.batch.models.PoolPatchParameter
        :param pool_patch_options: Parameter group.
        :type pool_patch_options: ~azure.batch.models.PoolPatchOptions
        :keyword callable cls: A custom type or function that will be passed the direct response
        :return: None or the result of cls(response)
        :rtype: None
        :raises: ~azure.core.exceptions.HttpResponseError
        """
        cls = kwargs.pop('cls', None)  # type: ClsType[None]
        error_map = kwargs.pop('error_map', {404: ResourceNotFoundError, 409: ResourceExistsError})
        
        _timeout = None
        _client_request_id = None
        _return_client_request_id = None
        _ocp_date = None
        _if_match = None
        _if_none_match = None
        _if_modified_since = None
        _if_unmodified_since = None
        if pool_patch_options is not None:
            _timeout = pool_patch_options.timeout
            _client_request_id = pool_patch_options.client_request_id
            _return_client_request_id = pool_patch_options.return_client_request_id
            _ocp_date = pool_patch_options.ocp_date
            _if_match = pool_patch_options.if_match
            _if_none_match = pool_patch_options.if_none_match
            _if_modified_since = pool_patch_options.if_modified_since
            _if_unmodified_since = pool_patch_options.if_unmodified_since
        api_version = "2020-03-01.11.0"
        content_type = kwargs.pop("content_type", "application/json; odata=minimalmetadata")

        # Construct URL
        url = self.patch.metadata['url']
        path_format_arguments = {
            'batchUrl': self._serialize.url("self._config.batch_url", self._config.batch_url, 'str', skip_quote=True),
            'poolId': self._serialize.url("pool_id", pool_id, 'str'),
        }
        url = self._client.format_url(url, **path_format_arguments)

        # Construct parameters
        query_parameters = {}  # type: Dict[str, Any]
        if _timeout is not None:
            query_parameters['timeout'] = self._serialize.query("timeout", _timeout, 'int')
        query_parameters['api-version'] = self._serialize.query("api_version", api_version, 'str')

        # Construct headers
        header_parameters = {}  # type: Dict[str, Any]
        if _client_request_id is not None:
            header_parameters['client-request-id'] = self._serialize.header("client_request_id", _client_request_id, 'str')
        if _return_client_request_id is not None:
            header_parameters['return-client-request-id'] = self._serialize.header("return_client_request_id", _return_client_request_id, 'bool')
        if _ocp_date is not None:
            header_parameters['ocp-date'] = self._serialize.header("ocp_date", _ocp_date, 'rfc-1123')
        if _if_match is not None:
            header_parameters['If-Match'] = self._serialize.header("if_match", _if_match, 'str')
        if _if_none_match is not None:
            header_parameters['If-None-Match'] = self._serialize.header("if_none_match", _if_none_match, 'str')
        if _if_modified_since is not None:
            header_parameters['If-Modified-Since'] = self._serialize.header("if_modified_since", _if_modified_since, 'rfc-1123')
        if _if_unmodified_since is not None:
            header_parameters['If-Unmodified-Since'] = self._serialize.header("if_unmodified_since", _if_unmodified_since, 'rfc-1123')
        header_parameters['Content-Type'] = self._serialize.header("content_type", content_type, 'str')

        # Construct and send request
        body_content_kwargs = {}  # type: Dict[str, Any]
        body_content = self._serialize.body(pool_patch_parameter, 'PoolPatchParameter')
        body_content_kwargs['content'] = body_content
        request = self._client.patch(url, query_parameters, header_parameters, **body_content_kwargs)

        pipeline_response = await self._client._pipeline.run(request, stream=False, **kwargs)
        response = pipeline_response.http_response

        if response.status_code not in [200]:
            map_error(status_code=response.status_code, response=response, error_map=error_map)
            error = self._deserialize(models.BatchError, response)
            raise HttpResponseError(response=response, model=error, error_format=ARMErrorFormat)

        response_headers = {}
        response_headers['client-request-id']=self._deserialize('str', response.headers.get('client-request-id'))
        response_headers['request-id']=self._deserialize('str', response.headers.get('request-id'))
        response_headers['ETag']=self._deserialize('str', response.headers.get('ETag'))
        response_headers['Last-Modified']=self._deserialize('rfc-1123', response.headers.get('Last-Modified'))
        response_headers['DataServiceId']=self._deserialize('str', response.headers.get('DataServiceId'))

        if cls:
          return cls(pipeline_response, None, response_headers)

    patch.metadata = {'url': '/pools/{poolId}'}

    async def disable_auto_scale(
        self,
        pool_id: str,
        pool_disable_auto_scale_options: Optional["models.PoolDisableAutoScaleOptions"] = None,
        **kwargs
    ) -> None:
        """Disables automatic scaling for a Pool.

        Disables automatic scaling for a Pool.

        :param pool_id: The ID of the Pool on which to disable automatic scaling.
        :type pool_id: str
        :param pool_disable_auto_scale_options: Parameter group.
        :type pool_disable_auto_scale_options: ~azure.batch.models.PoolDisableAutoScaleOptions
        :keyword callable cls: A custom type or function that will be passed the direct response
        :return: None or the result of cls(response)
        :rtype: None
        :raises: ~azure.core.exceptions.HttpResponseError
        """
        cls = kwargs.pop('cls', None)  # type: ClsType[None]
        error_map = kwargs.pop('error_map', {404: ResourceNotFoundError, 409: ResourceExistsError})
        
        _timeout = None
        _client_request_id = None
        _return_client_request_id = None
        _ocp_date = None
        if pool_disable_auto_scale_options is not None:
            _timeout = pool_disable_auto_scale_options.timeout
            _client_request_id = pool_disable_auto_scale_options.client_request_id
            _return_client_request_id = pool_disable_auto_scale_options.return_client_request_id
            _ocp_date = pool_disable_auto_scale_options.ocp_date
        api_version = "2020-03-01.11.0"

        # Construct URL
        url = self.disable_auto_scale.metadata['url']
        path_format_arguments = {
            'batchUrl': self._serialize.url("self._config.batch_url", self._config.batch_url, 'str', skip_quote=True),
            'poolId': self._serialize.url("pool_id", pool_id, 'str'),
        }
        url = self._client.format_url(url, **path_format_arguments)

        # Construct parameters
        query_parameters = {}  # type: Dict[str, Any]
        if _timeout is not None:
            query_parameters['timeout'] = self._serialize.query("timeout", _timeout, 'int')
        query_parameters['api-version'] = self._serialize.query("api_version", api_version, 'str')

        # Construct headers
        header_parameters = {}  # type: Dict[str, Any]
        if _client_request_id is not None:
            header_parameters['client-request-id'] = self._serialize.header("client_request_id", _client_request_id, 'str')
        if _return_client_request_id is not None:
            header_parameters['return-client-request-id'] = self._serialize.header("return_client_request_id", _return_client_request_id, 'bool')
        if _ocp_date is not None:
            header_parameters['ocp-date'] = self._serialize.header("ocp_date", _ocp_date, 'rfc-1123')

        # Construct and send request
        request = self._client.post(url, query_parameters, header_parameters)
        pipeline_response = await self._client._pipeline.run(request, stream=False, **kwargs)
        response = pipeline_response.http_response

        if response.status_code not in [200]:
            map_error(status_code=response.status_code, response=response, error_map=error_map)
            error = self._deserialize(models.BatchError, response)
            raise HttpResponseError(response=response, model=error, error_format=ARMErrorFormat)

        response_headers = {}
        response_headers['client-request-id']=self._deserialize('str', response.headers.get('client-request-id'))
        response_headers['request-id']=self._deserialize('str', response.headers.get('request-id'))
        response_headers['ETag']=self._deserialize('str', response.headers.get('ETag'))
        response_headers['Last-Modified']=self._deserialize('rfc-1123', response.headers.get('Last-Modified'))
        response_headers['DataServiceId']=self._deserialize('str', response.headers.get('DataServiceId'))

        if cls:
          return cls(pipeline_response, None, response_headers)

    disable_auto_scale.metadata = {'url': '/pools/{poolId}/disableautoscale'}

    async def enable_auto_scale(
        self,
        pool_id: str,
        auto_scale_formula: Optional[str] = None,
        auto_scale_evaluation_interval: Optional[datetime.timedelta] = None,
        pool_enable_auto_scale_options: Optional["models.PoolEnableAutoScaleOptions"] = None,
        **kwargs
    ) -> None:
        """You cannot enable automatic scaling on a Pool if a resize operation is in progress on the Pool. If automatic scaling of the Pool is currently disabled, you must specify a valid autoscale formula as part of the request. If automatic scaling of the Pool is already enabled, you may specify a new autoscale formula and/or a new evaluation interval. You cannot call this API for the same Pool more than once every 30 seconds.

        Enables automatic scaling for a Pool.

        :param pool_id: The ID of the Pool on which to enable automatic scaling.
        :type pool_id: str
        :param auto_scale_formula: The formula is checked for validity before it is applied to the
         Pool. If the formula is not valid, the Batch service rejects the request with detailed error
         information. For more information about specifying this formula, see Automatically scale
         Compute Nodes in an Azure Batch Pool (https://azure.microsoft.com/en-
         us/documentation/articles/batch-automatic-scaling).
        :type auto_scale_formula: str
        :param auto_scale_evaluation_interval: The default value is 15 minutes. The minimum and maximum
         value are 5 minutes and 168 hours respectively. If you specify a value less than 5 minutes or
         greater than 168 hours, the Batch service rejects the request with an invalid property value
         error; if you are calling the REST API directly, the HTTP status code is 400 (Bad Request). If
         you specify a new interval, then the existing autoscale evaluation schedule will be stopped and
         a new autoscale evaluation schedule will be started, with its starting time being the time when
         this request was issued.
        :type auto_scale_evaluation_interval: ~datetime.timedelta
        :param pool_enable_auto_scale_options: Parameter group.
        :type pool_enable_auto_scale_options: ~azure.batch.models.PoolEnableAutoScaleOptions
        :keyword callable cls: A custom type or function that will be passed the direct response
        :return: None or the result of cls(response)
        :rtype: None
        :raises: ~azure.core.exceptions.HttpResponseError
        """
        cls = kwargs.pop('cls', None)  # type: ClsType[None]
        error_map = kwargs.pop('error_map', {404: ResourceNotFoundError, 409: ResourceExistsError})
        
        _timeout = None
        _client_request_id = None
        _return_client_request_id = None
        _ocp_date = None
        _if_match = None
        _if_none_match = None
        _if_modified_since = None
        _if_unmodified_since = None
        if pool_enable_auto_scale_options is not None:
            _timeout = pool_enable_auto_scale_options.timeout
            _client_request_id = pool_enable_auto_scale_options.client_request_id
            _return_client_request_id = pool_enable_auto_scale_options.return_client_request_id
            _ocp_date = pool_enable_auto_scale_options.ocp_date
            _if_match = pool_enable_auto_scale_options.if_match
            _if_none_match = pool_enable_auto_scale_options.if_none_match
            _if_modified_since = pool_enable_auto_scale_options.if_modified_since
            _if_unmodified_since = pool_enable_auto_scale_options.if_unmodified_since

        _pool_enable_auto_scale_parameter = models.PoolEnableAutoScaleParameter(auto_scale_formula=auto_scale_formula, auto_scale_evaluation_interval=auto_scale_evaluation_interval)
        api_version = "2020-03-01.11.0"
        content_type = kwargs.pop("content_type", "application/json; odata=minimalmetadata")

        # Construct URL
        url = self.enable_auto_scale.metadata['url']
        path_format_arguments = {
            'batchUrl': self._serialize.url("self._config.batch_url", self._config.batch_url, 'str', skip_quote=True),
            'poolId': self._serialize.url("pool_id", pool_id, 'str'),
        }
        url = self._client.format_url(url, **path_format_arguments)

        # Construct parameters
        query_parameters = {}  # type: Dict[str, Any]
        if _timeout is not None:
            query_parameters['timeout'] = self._serialize.query("timeout", _timeout, 'int')
        query_parameters['api-version'] = self._serialize.query("api_version", api_version, 'str')

        # Construct headers
        header_parameters = {}  # type: Dict[str, Any]
        if _client_request_id is not None:
            header_parameters['client-request-id'] = self._serialize.header("client_request_id", _client_request_id, 'str')
        if _return_client_request_id is not None:
            header_parameters['return-client-request-id'] = self._serialize.header("return_client_request_id", _return_client_request_id, 'bool')
        if _ocp_date is not None:
            header_parameters['ocp-date'] = self._serialize.header("ocp_date", _ocp_date, 'rfc-1123')
        if _if_match is not None:
            header_parameters['If-Match'] = self._serialize.header("if_match", _if_match, 'str')
        if _if_none_match is not None:
            header_parameters['If-None-Match'] = self._serialize.header("if_none_match", _if_none_match, 'str')
        if _if_modified_since is not None:
            header_parameters['If-Modified-Since'] = self._serialize.header("if_modified_since", _if_modified_since, 'rfc-1123')
        if _if_unmodified_since is not None:
            header_parameters['If-Unmodified-Since'] = self._serialize.header("if_unmodified_since", _if_unmodified_since, 'rfc-1123')
        header_parameters['Content-Type'] = self._serialize.header("content_type", content_type, 'str')

        # Construct and send request
        body_content_kwargs = {}  # type: Dict[str, Any]
        body_content = self._serialize.body(_pool_enable_auto_scale_parameter, 'PoolEnableAutoScaleParameter')
        body_content_kwargs['content'] = body_content
        request = self._client.post(url, query_parameters, header_parameters, **body_content_kwargs)

        pipeline_response = await self._client._pipeline.run(request, stream=False, **kwargs)
        response = pipeline_response.http_response

        if response.status_code not in [200]:
            map_error(status_code=response.status_code, response=response, error_map=error_map)
            error = self._deserialize(models.BatchError, response)
            raise HttpResponseError(response=response, model=error, error_format=ARMErrorFormat)

        response_headers = {}
        response_headers['client-request-id']=self._deserialize('str', response.headers.get('client-request-id'))
        response_headers['request-id']=self._deserialize('str', response.headers.get('request-id'))
        response_headers['ETag']=self._deserialize('str', response.headers.get('ETag'))
        response_headers['Last-Modified']=self._deserialize('rfc-1123', response.headers.get('Last-Modified'))
        response_headers['DataServiceId']=self._deserialize('str', response.headers.get('DataServiceId'))

        if cls:
          return cls(pipeline_response, None, response_headers)

    enable_auto_scale.metadata = {'url': '/pools/{poolId}/enableautoscale'}

    async def evaluate_auto_scale(
        self,
        pool_id: str,
        auto_scale_formula: str,
        pool_evaluate_auto_scale_options: Optional["models.PoolEvaluateAutoScaleOptions"] = None,
        **kwargs
    ) -> "models.AutoScaleRun":
        """This API is primarily for validating an autoscale formula, as it simply returns the result without applying the formula to the Pool. The Pool must have auto scaling enabled in order to evaluate a formula.

        Gets the result of evaluating an automatic scaling formula on the Pool.

        :param pool_id: The ID of the Pool on which to evaluate the automatic scaling formula.
        :type pool_id: str
        :param auto_scale_formula: The formula is validated and its results calculated, but it is not
         applied to the Pool. To apply the formula to the Pool, 'Enable automatic scaling on a Pool'.
         For more information about specifying this formula, see Automatically scale Compute Nodes in an
         Azure Batch Pool (https://azure.microsoft.com/en-us/documentation/articles/batch-automatic-
         scaling).
        :type auto_scale_formula: str
        :param pool_evaluate_auto_scale_options: Parameter group.
        :type pool_evaluate_auto_scale_options: ~azure.batch.models.PoolEvaluateAutoScaleOptions
        :keyword callable cls: A custom type or function that will be passed the direct response
        :return: AutoScaleRun or the result of cls(response)
        :rtype: ~azure.batch.models.AutoScaleRun
        :raises: ~azure.core.exceptions.HttpResponseError
        """
        cls = kwargs.pop('cls', None)  # type: ClsType["models.AutoScaleRun"]
        error_map = kwargs.pop('error_map', {404: ResourceNotFoundError, 409: ResourceExistsError})
        
        _timeout = None
        _client_request_id = None
        _return_client_request_id = None
        _ocp_date = None
        if pool_evaluate_auto_scale_options is not None:
            _timeout = pool_evaluate_auto_scale_options.timeout
            _client_request_id = pool_evaluate_auto_scale_options.client_request_id
            _return_client_request_id = pool_evaluate_auto_scale_options.return_client_request_id
            _ocp_date = pool_evaluate_auto_scale_options.ocp_date

        _pool_evaluate_auto_scale_parameter = models.PoolEvaluateAutoScaleParameter(auto_scale_formula=auto_scale_formula)
        api_version = "2020-03-01.11.0"
        content_type = kwargs.pop("content_type", "application/json; odata=minimalmetadata")

        # Construct URL
        url = self.evaluate_auto_scale.metadata['url']
        path_format_arguments = {
            'batchUrl': self._serialize.url("self._config.batch_url", self._config.batch_url, 'str', skip_quote=True),
            'poolId': self._serialize.url("pool_id", pool_id, 'str'),
        }
        url = self._client.format_url(url, **path_format_arguments)

        # Construct parameters
        query_parameters = {}  # type: Dict[str, Any]
        if _timeout is not None:
            query_parameters['timeout'] = self._serialize.query("timeout", _timeout, 'int')
        query_parameters['api-version'] = self._serialize.query("api_version", api_version, 'str')

        # Construct headers
        header_parameters = {}  # type: Dict[str, Any]
        if _client_request_id is not None:
            header_parameters['client-request-id'] = self._serialize.header("client_request_id", _client_request_id, 'str')
        if _return_client_request_id is not None:
            header_parameters['return-client-request-id'] = self._serialize.header("return_client_request_id", _return_client_request_id, 'bool')
        if _ocp_date is not None:
            header_parameters['ocp-date'] = self._serialize.header("ocp_date", _ocp_date, 'rfc-1123')
        header_parameters['Content-Type'] = self._serialize.header("content_type", content_type, 'str')
        header_parameters['Accept'] = 'application/json'

        # Construct and send request
        body_content_kwargs = {}  # type: Dict[str, Any]
        body_content = self._serialize.body(_pool_evaluate_auto_scale_parameter, 'PoolEvaluateAutoScaleParameter')
        body_content_kwargs['content'] = body_content
        request = self._client.post(url, query_parameters, header_parameters, **body_content_kwargs)

        pipeline_response = await self._client._pipeline.run(request, stream=False, **kwargs)
        response = pipeline_response.http_response

        if response.status_code not in [200]:
            map_error(status_code=response.status_code, response=response, error_map=error_map)
            error = self._deserialize(models.BatchError, response)
            raise HttpResponseError(response=response, model=error, error_format=ARMErrorFormat)

        response_headers = {}
        response_headers['client-request-id']=self._deserialize('str', response.headers.get('client-request-id'))
        response_headers['request-id']=self._deserialize('str', response.headers.get('request-id'))
        response_headers['ETag']=self._deserialize('str', response.headers.get('ETag'))
        response_headers['Last-Modified']=self._deserialize('rfc-1123', response.headers.get('Last-Modified'))
        response_headers['DataServiceId']=self._deserialize('str', response.headers.get('DataServiceId'))
        deserialized = self._deserialize('AutoScaleRun', pipeline_response)

        if cls:
          return cls(pipeline_response, deserialized, response_headers)

        return deserialized
    evaluate_auto_scale.metadata = {'url': '/pools/{poolId}/evaluateautoscale'}

    async def resize(
        self,
        pool_id: str,
        pool_resize_parameter: "models.PoolResizeParameter",
        pool_resize_options: Optional["models.PoolResizeOptions"] = None,
        **kwargs
    ) -> None:
        """You can only resize a Pool when its allocation state is steady. If the Pool is already resizing, the request fails with status code 409. When you resize a Pool, the Pool's allocation state changes from steady to resizing. You cannot resize Pools which are configured for automatic scaling. If you try to do this, the Batch service returns an error 409. If you resize a Pool downwards, the Batch service chooses which Compute Nodes to remove. To remove specific Compute Nodes, use the Pool remove Compute Nodes API instead.

        Changes the number of Compute Nodes that are assigned to a Pool.

        :param pool_id: The ID of the Pool to resize.
        :type pool_id: str
        :param pool_resize_parameter: The parameters for the request.
        :type pool_resize_parameter: ~azure.batch.models.PoolResizeParameter
        :param pool_resize_options: Parameter group.
        :type pool_resize_options: ~azure.batch.models.PoolResizeOptions
        :keyword callable cls: A custom type or function that will be passed the direct response
        :return: None or the result of cls(response)
        :rtype: None
        :raises: ~azure.core.exceptions.HttpResponseError
        """
        cls = kwargs.pop('cls', None)  # type: ClsType[None]
        error_map = kwargs.pop('error_map', {404: ResourceNotFoundError, 409: ResourceExistsError})
        
        _timeout = None
        _client_request_id = None
        _return_client_request_id = None
        _ocp_date = None
        _if_match = None
        _if_none_match = None
        _if_modified_since = None
        _if_unmodified_since = None
        if pool_resize_options is not None:
            _timeout = pool_resize_options.timeout
            _client_request_id = pool_resize_options.client_request_id
            _return_client_request_id = pool_resize_options.return_client_request_id
            _ocp_date = pool_resize_options.ocp_date
            _if_match = pool_resize_options.if_match
            _if_none_match = pool_resize_options.if_none_match
            _if_modified_since = pool_resize_options.if_modified_since
            _if_unmodified_since = pool_resize_options.if_unmodified_since
        api_version = "2020-03-01.11.0"
        content_type = kwargs.pop("content_type", "application/json; odata=minimalmetadata")

        # Construct URL
        url = self.resize.metadata['url']
        path_format_arguments = {
            'batchUrl': self._serialize.url("self._config.batch_url", self._config.batch_url, 'str', skip_quote=True),
            'poolId': self._serialize.url("pool_id", pool_id, 'str'),
        }
        url = self._client.format_url(url, **path_format_arguments)

        # Construct parameters
        query_parameters = {}  # type: Dict[str, Any]
        if _timeout is not None:
            query_parameters['timeout'] = self._serialize.query("timeout", _timeout, 'int')
        query_parameters['api-version'] = self._serialize.query("api_version", api_version, 'str')

        # Construct headers
        header_parameters = {}  # type: Dict[str, Any]
        if _client_request_id is not None:
            header_parameters['client-request-id'] = self._serialize.header("client_request_id", _client_request_id, 'str')
        if _return_client_request_id is not None:
            header_parameters['return-client-request-id'] = self._serialize.header("return_client_request_id", _return_client_request_id, 'bool')
        if _ocp_date is not None:
            header_parameters['ocp-date'] = self._serialize.header("ocp_date", _ocp_date, 'rfc-1123')
        if _if_match is not None:
            header_parameters['If-Match'] = self._serialize.header("if_match", _if_match, 'str')
        if _if_none_match is not None:
            header_parameters['If-None-Match'] = self._serialize.header("if_none_match", _if_none_match, 'str')
        if _if_modified_since is not None:
            header_parameters['If-Modified-Since'] = self._serialize.header("if_modified_since", _if_modified_since, 'rfc-1123')
        if _if_unmodified_since is not None:
            header_parameters['If-Unmodified-Since'] = self._serialize.header("if_unmodified_since", _if_unmodified_since, 'rfc-1123')
        header_parameters['Content-Type'] = self._serialize.header("content_type", content_type, 'str')

        # Construct and send request
        body_content_kwargs = {}  # type: Dict[str, Any]
        body_content = self._serialize.body(pool_resize_parameter, 'PoolResizeParameter')
        body_content_kwargs['content'] = body_content
        request = self._client.post(url, query_parameters, header_parameters, **body_content_kwargs)

        pipeline_response = await self._client._pipeline.run(request, stream=False, **kwargs)
        response = pipeline_response.http_response

        if response.status_code not in [202]:
            map_error(status_code=response.status_code, response=response, error_map=error_map)
            error = self._deserialize(models.BatchError, response)
            raise HttpResponseError(response=response, model=error, error_format=ARMErrorFormat)

        response_headers = {}
        response_headers['client-request-id']=self._deserialize('str', response.headers.get('client-request-id'))
        response_headers['request-id']=self._deserialize('str', response.headers.get('request-id'))
        response_headers['ETag']=self._deserialize('str', response.headers.get('ETag'))
        response_headers['Last-Modified']=self._deserialize('rfc-1123', response.headers.get('Last-Modified'))
        response_headers['DataServiceId']=self._deserialize('str', response.headers.get('DataServiceId'))

        if cls:
          return cls(pipeline_response, None, response_headers)

    resize.metadata = {'url': '/pools/{poolId}/resize'}

    async def stop_resize(
        self,
        pool_id: str,
        pool_stop_resize_options: Optional["models.PoolStopResizeOptions"] = None,
        **kwargs
    ) -> None:
        """This does not restore the Pool to its previous state before the resize operation: it only stops any further changes being made, and the Pool maintains its current state. After stopping, the Pool stabilizes at the number of Compute Nodes it was at when the stop operation was done. During the stop operation, the Pool allocation state changes first to stopping and then to steady. A resize operation need not be an explicit resize Pool request; this API can also be used to halt the initial sizing of the Pool when it is created.

        Stops an ongoing resize operation on the Pool.

        :param pool_id: The ID of the Pool whose resizing you want to stop.
        :type pool_id: str
        :param pool_stop_resize_options: Parameter group.
        :type pool_stop_resize_options: ~azure.batch.models.PoolStopResizeOptions
        :keyword callable cls: A custom type or function that will be passed the direct response
        :return: None or the result of cls(response)
        :rtype: None
        :raises: ~azure.core.exceptions.HttpResponseError
        """
        cls = kwargs.pop('cls', None)  # type: ClsType[None]
        error_map = kwargs.pop('error_map', {404: ResourceNotFoundError, 409: ResourceExistsError})
        
        _timeout = None
        _client_request_id = None
        _return_client_request_id = None
        _ocp_date = None
        _if_match = None
        _if_none_match = None
        _if_modified_since = None
        _if_unmodified_since = None
        if pool_stop_resize_options is not None:
            _timeout = pool_stop_resize_options.timeout
            _client_request_id = pool_stop_resize_options.client_request_id
            _return_client_request_id = pool_stop_resize_options.return_client_request_id
            _ocp_date = pool_stop_resize_options.ocp_date
            _if_match = pool_stop_resize_options.if_match
            _if_none_match = pool_stop_resize_options.if_none_match
            _if_modified_since = pool_stop_resize_options.if_modified_since
            _if_unmodified_since = pool_stop_resize_options.if_unmodified_since
        api_version = "2020-03-01.11.0"

        # Construct URL
        url = self.stop_resize.metadata['url']
        path_format_arguments = {
            'batchUrl': self._serialize.url("self._config.batch_url", self._config.batch_url, 'str', skip_quote=True),
            'poolId': self._serialize.url("pool_id", pool_id, 'str'),
        }
        url = self._client.format_url(url, **path_format_arguments)

        # Construct parameters
        query_parameters = {}  # type: Dict[str, Any]
        if _timeout is not None:
            query_parameters['timeout'] = self._serialize.query("timeout", _timeout, 'int')
        query_parameters['api-version'] = self._serialize.query("api_version", api_version, 'str')

        # Construct headers
        header_parameters = {}  # type: Dict[str, Any]
        if _client_request_id is not None:
            header_parameters['client-request-id'] = self._serialize.header("client_request_id", _client_request_id, 'str')
        if _return_client_request_id is not None:
            header_parameters['return-client-request-id'] = self._serialize.header("return_client_request_id", _return_client_request_id, 'bool')
        if _ocp_date is not None:
            header_parameters['ocp-date'] = self._serialize.header("ocp_date", _ocp_date, 'rfc-1123')
        if _if_match is not None:
            header_parameters['If-Match'] = self._serialize.header("if_match", _if_match, 'str')
        if _if_none_match is not None:
            header_parameters['If-None-Match'] = self._serialize.header("if_none_match", _if_none_match, 'str')
        if _if_modified_since is not None:
            header_parameters['If-Modified-Since'] = self._serialize.header("if_modified_since", _if_modified_since, 'rfc-1123')
        if _if_unmodified_since is not None:
            header_parameters['If-Unmodified-Since'] = self._serialize.header("if_unmodified_since", _if_unmodified_since, 'rfc-1123')

        # Construct and send request
        request = self._client.post(url, query_parameters, header_parameters)
        pipeline_response = await self._client._pipeline.run(request, stream=False, **kwargs)
        response = pipeline_response.http_response

        if response.status_code not in [202]:
            map_error(status_code=response.status_code, response=response, error_map=error_map)
            error = self._deserialize(models.BatchError, response)
            raise HttpResponseError(response=response, model=error, error_format=ARMErrorFormat)

        response_headers = {}
        response_headers['client-request-id']=self._deserialize('str', response.headers.get('client-request-id'))
        response_headers['request-id']=self._deserialize('str', response.headers.get('request-id'))
        response_headers['ETag']=self._deserialize('str', response.headers.get('ETag'))
        response_headers['Last-Modified']=self._deserialize('rfc-1123', response.headers.get('Last-Modified'))
        response_headers['DataServiceId']=self._deserialize('str', response.headers.get('DataServiceId'))

        if cls:
          return cls(pipeline_response, None, response_headers)

    stop_resize.metadata = {'url': '/pools/{poolId}/stopresize'}

    async def update_properties(
        self,
        pool_id: str,
        pool_update_properties_parameter: "models.PoolUpdatePropertiesParameter",
        pool_update_properties_options: Optional["models.PoolUpdatePropertiesOptions"] = None,
        **kwargs
    ) -> None:
        """This fully replaces all the updatable properties of the Pool. For example, if the Pool has a StartTask associated with it and if StartTask is not specified with this request, then the Batch service will remove the existing StartTask.

        Updates the properties of the specified Pool.

        :param pool_id: The ID of the Pool to update.
        :type pool_id: str
        :param pool_update_properties_parameter: The parameters for the request.
        :type pool_update_properties_parameter: ~azure.batch.models.PoolUpdatePropertiesParameter
        :param pool_update_properties_options: Parameter group.
        :type pool_update_properties_options: ~azure.batch.models.PoolUpdatePropertiesOptions
        :keyword callable cls: A custom type or function that will be passed the direct response
        :return: None or the result of cls(response)
        :rtype: None
        :raises: ~azure.core.exceptions.HttpResponseError
        """
        cls = kwargs.pop('cls', None)  # type: ClsType[None]
        error_map = kwargs.pop('error_map', {404: ResourceNotFoundError, 409: ResourceExistsError})
        
        _timeout = None
        _client_request_id = None
        _return_client_request_id = None
        _ocp_date = None
        if pool_update_properties_options is not None:
            _timeout = pool_update_properties_options.timeout
            _client_request_id = pool_update_properties_options.client_request_id
            _return_client_request_id = pool_update_properties_options.return_client_request_id
            _ocp_date = pool_update_properties_options.ocp_date
        api_version = "2020-03-01.11.0"
        content_type = kwargs.pop("content_type", "application/json; odata=minimalmetadata")

        # Construct URL
        url = self.update_properties.metadata['url']
        path_format_arguments = {
            'batchUrl': self._serialize.url("self._config.batch_url", self._config.batch_url, 'str', skip_quote=True),
            'poolId': self._serialize.url("pool_id", pool_id, 'str'),
        }
        url = self._client.format_url(url, **path_format_arguments)

        # Construct parameters
        query_parameters = {}  # type: Dict[str, Any]
        if _timeout is not None:
            query_parameters['timeout'] = self._serialize.query("timeout", _timeout, 'int')
        query_parameters['api-version'] = self._serialize.query("api_version", api_version, 'str')

        # Construct headers
        header_parameters = {}  # type: Dict[str, Any]
        if _client_request_id is not None:
            header_parameters['client-request-id'] = self._serialize.header("client_request_id", _client_request_id, 'str')
        if _return_client_request_id is not None:
            header_parameters['return-client-request-id'] = self._serialize.header("return_client_request_id", _return_client_request_id, 'bool')
        if _ocp_date is not None:
            header_parameters['ocp-date'] = self._serialize.header("ocp_date", _ocp_date, 'rfc-1123')
        header_parameters['Content-Type'] = self._serialize.header("content_type", content_type, 'str')

        # Construct and send request
        body_content_kwargs = {}  # type: Dict[str, Any]
        body_content = self._serialize.body(pool_update_properties_parameter, 'PoolUpdatePropertiesParameter')
        body_content_kwargs['content'] = body_content
        request = self._client.post(url, query_parameters, header_parameters, **body_content_kwargs)

        pipeline_response = await self._client._pipeline.run(request, stream=False, **kwargs)
        response = pipeline_response.http_response

        if response.status_code not in [204]:
            map_error(status_code=response.status_code, response=response, error_map=error_map)
            error = self._deserialize(models.BatchError, response)
            raise HttpResponseError(response=response, model=error, error_format=ARMErrorFormat)

        response_headers = {}
        response_headers['client-request-id']=self._deserialize('str', response.headers.get('client-request-id'))
        response_headers['request-id']=self._deserialize('str', response.headers.get('request-id'))
        response_headers['ETag']=self._deserialize('str', response.headers.get('ETag'))
        response_headers['Last-Modified']=self._deserialize('rfc-1123', response.headers.get('Last-Modified'))
        response_headers['DataServiceId']=self._deserialize('str', response.headers.get('DataServiceId'))

        if cls:
          return cls(pipeline_response, None, response_headers)

    update_properties.metadata = {'url': '/pools/{poolId}/updateproperties'}

    async def remove_nodes(
        self,
        pool_id: str,
        node_remove_parameter: "models.NodeRemoveParameter",
        pool_remove_nodes_options: Optional["models.PoolRemoveNodesOptions"] = None,
        **kwargs
    ) -> None:
        """This operation can only run when the allocation state of the Pool is steady. When this operation runs, the allocation state changes from steady to resizing.

        Removes Compute Nodes from the specified Pool.

        :param pool_id: The ID of the Pool from which you want to remove Compute Nodes.
        :type pool_id: str
        :param node_remove_parameter: The parameters for the request.
        :type node_remove_parameter: ~azure.batch.models.NodeRemoveParameter
        :param pool_remove_nodes_options: Parameter group.
        :type pool_remove_nodes_options: ~azure.batch.models.PoolRemoveNodesOptions
        :keyword callable cls: A custom type or function that will be passed the direct response
        :return: None or the result of cls(response)
        :rtype: None
        :raises: ~azure.core.exceptions.HttpResponseError
        """
        cls = kwargs.pop('cls', None)  # type: ClsType[None]
        error_map = kwargs.pop('error_map', {404: ResourceNotFoundError, 409: ResourceExistsError})
        
        _timeout = None
        _client_request_id = None
        _return_client_request_id = None
        _ocp_date = None
        _if_match = None
        _if_none_match = None
        _if_modified_since = None
        _if_unmodified_since = None
        if pool_remove_nodes_options is not None:
            _timeout = pool_remove_nodes_options.timeout
            _client_request_id = pool_remove_nodes_options.client_request_id
            _return_client_request_id = pool_remove_nodes_options.return_client_request_id
            _ocp_date = pool_remove_nodes_options.ocp_date
            _if_match = pool_remove_nodes_options.if_match
            _if_none_match = pool_remove_nodes_options.if_none_match
            _if_modified_since = pool_remove_nodes_options.if_modified_since
            _if_unmodified_since = pool_remove_nodes_options.if_unmodified_since
        api_version = "2020-03-01.11.0"
        content_type = kwargs.pop("content_type", "application/json; odata=minimalmetadata")

        # Construct URL
        url = self.remove_nodes.metadata['url']
        path_format_arguments = {
            'batchUrl': self._serialize.url("self._config.batch_url", self._config.batch_url, 'str', skip_quote=True),
            'poolId': self._serialize.url("pool_id", pool_id, 'str'),
        }
        url = self._client.format_url(url, **path_format_arguments)

        # Construct parameters
        query_parameters = {}  # type: Dict[str, Any]
        if _timeout is not None:
            query_parameters['timeout'] = self._serialize.query("timeout", _timeout, 'int')
        query_parameters['api-version'] = self._serialize.query("api_version", api_version, 'str')

        # Construct headers
        header_parameters = {}  # type: Dict[str, Any]
        if _client_request_id is not None:
            header_parameters['client-request-id'] = self._serialize.header("client_request_id", _client_request_id, 'str')
        if _return_client_request_id is not None:
            header_parameters['return-client-request-id'] = self._serialize.header("return_client_request_id", _return_client_request_id, 'bool')
        if _ocp_date is not None:
            header_parameters['ocp-date'] = self._serialize.header("ocp_date", _ocp_date, 'rfc-1123')
        if _if_match is not None:
            header_parameters['If-Match'] = self._serialize.header("if_match", _if_match, 'str')
        if _if_none_match is not None:
            header_parameters['If-None-Match'] = self._serialize.header("if_none_match", _if_none_match, 'str')
        if _if_modified_since is not None:
            header_parameters['If-Modified-Since'] = self._serialize.header("if_modified_since", _if_modified_since, 'rfc-1123')
        if _if_unmodified_since is not None:
            header_parameters['If-Unmodified-Since'] = self._serialize.header("if_unmodified_since", _if_unmodified_since, 'rfc-1123')
        header_parameters['Content-Type'] = self._serialize.header("content_type", content_type, 'str')

        # Construct and send request
        body_content_kwargs = {}  # type: Dict[str, Any]
        body_content = self._serialize.body(node_remove_parameter, 'NodeRemoveParameter')
        body_content_kwargs['content'] = body_content
        request = self._client.post(url, query_parameters, header_parameters, **body_content_kwargs)

        pipeline_response = await self._client._pipeline.run(request, stream=False, **kwargs)
        response = pipeline_response.http_response

        if response.status_code not in [202]:
            map_error(status_code=response.status_code, response=response, error_map=error_map)
            error = self._deserialize(models.BatchError, response)
            raise HttpResponseError(response=response, model=error, error_format=ARMErrorFormat)

        response_headers = {}
        response_headers['client-request-id']=self._deserialize('str', response.headers.get('client-request-id'))
        response_headers['request-id']=self._deserialize('str', response.headers.get('request-id'))
        response_headers['ETag']=self._deserialize('str', response.headers.get('ETag'))
        response_headers['Last-Modified']=self._deserialize('rfc-1123', response.headers.get('Last-Modified'))
        response_headers['DataServiceId']=self._deserialize('str', response.headers.get('DataServiceId'))

        if cls:
          return cls(pipeline_response, None, response_headers)

    remove_nodes.metadata = {'url': '/pools/{poolId}/removenodes'}
